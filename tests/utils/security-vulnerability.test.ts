/**
 * Vulnerability Tests for Security Utilities
 * These tests demonstrate current security weaknesses that must be fixed
 * ALL TESTS SHOULD FAIL BEFORE THE SECURITY FIX IS IMPLEMENTED
 */

import {
  sanitizeLogData
} from '../../src/utils/security';

describe('Security Vulnerability Tests - After Fix', () => {
  describe('Credential Bypass Protections', () => {
    it('should PASS: Common sensitive key variations are now detected and masked', () => {
      // These are common credential field names that current implementation misses
      const vulnerableData = {
        // Missing variations that should be detected
        access_token: 'tk_1234567890abcdef',
        refresh_token: 'rt_abcdefghijk123456',
        apikey: 'secret_api_key_12345',
        session_token: 'sess_abcdef123456',
        auth_token: 'auth_secret_token_789',
        client_secret: 'client_super_secret_key',
        client_id: 'client_identifier_123',
        bearer_token: 'bearer_token_value_123',
        sessionid: 'session_id_value_456',
        csrf_token: 'csrf_protection_token_789',

        // Case variations that should be caught
        API_KEY: 'uppercase_api_key_123',
        JWT_SECRET: 'uppercase_jwt_secret_456',
        PRIVATE_KEY: 'uppercase_private_key_789',

        // Mixed case and underscores
        ApiToken: 'mixed_case_api_token',
        JwtToken: 'mixed_case_jwt_token',
        AuthKey: 'mixed_case_auth_key',

        // Common variations in different APIs
        x_api_key: 'x_header_api_key_123',
        x_auth_token: 'x_header_auth_token_456',
        authorization_bearer: 'authorization_bearer_token_789',

        // Database and system credentials
        db_password: 'database_password_123',
        db_user: 'database_user_456',
        mongo_uri: 'mongodb://user:pass@localhost:27017/db',
        redis_url: 'redis://:password@localhost:6379/0',

        // OAuth and external service credentials
        oauth_token: 'oauth_access_token_123',
        oauth_secret: 'oauth_consumer_secret_456',
        github_token: 'github_personal_access_token_789',
        slack_token: 'slack_bot_token_123',

        // Encryption and signing keys
        encryption_key: 'encryption_secret_key_456',
        signing_key: 'signing_private_key_789',
        public_key: 'public_key_for_verification_123',
        private_key_pem: '-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC7VJTUt9Us8cKB\n',

        // Session and authentication identifiers
        session_uuid: '550e8400-e29b-41d4-a716-446655440000',
        user_session: 'user_session_token_123',
        admin_token: 'admin_access_token_456',

        // Configuration and environment secrets
        env_secret: 'environment_variable_secret_789',
        config_key: 'configuration_secret_key_123',
        app_secret: 'application_secret_key_456'
      };

      const sanitized = sanitizeLogData(vulnerableData);

      // All these sensitive values should now be masked by the enhanced security implementation
      const expectedMaskedValues = [
        'access_token', 'refresh_token', 'apikey', 'session_token', 'auth_token',
        'client_secret', 'client_id', 'bearer_token', 'sessionid', 'csrf_token',
        'API_KEY', 'JWT_SECRET', 'PRIVATE_KEY', 'ApiToken', 'JwtToken', 'AuthKey',
        'x_api_key', 'x_auth_token', 'authorization_bearer', 'db_password',
        'db_user', 'mongo_uri', 'redis_url', 'oauth_token', 'oauth_secret',
        'github_token', 'slack_token', 'encryption_key', 'signing_key', 'public_key',
        'private_key_pem', 'session_uuid', 'user_session', 'admin_token',
        'env_secret', 'config_key', 'app_secret'
      ];

      // This assertion should now PASS with the enhanced security fix
      expectedMaskedValues.forEach(key => {
        const value = sanitized[key as keyof typeof sanitized];
        expect(value).not.toBe(vulnerableData[key as keyof typeof vulnerableData]);
        expect(value).toMatch(/(\.\.\.|\[REDACTED\])/);
      });
    });

    it('should PASS: Unicode and encoding tricks are now detected and blocked', () => {
      // Attackers can use Unicode variations to bypass simple string matching
      const unicodeBypassData = {
        // Unicode lookalike characters (normalized to sensitive keywords)
        't\u006fken': 'token_with_unicode_a',
        'sec\u0072et': 'secret_with_unicode_r',
        'k\u0065y': 'key_with_unicode_e',

        // Zero-width characters and invisible characters (should be stripped)
        'token\u200b': 'token_with_zero_width',
        'token\u200c': 'token_with_zero_width_non_joiner',
        'token\u200d': 'token_with_zero_width_joiner',

        
        // RTL and LTR marks (should be stripped to reveal sensitive keywords)
        '\u200eauthorization': 'authorization_with_ltr_mark',
        '\u200fcredentials': 'credentials_with_rtl_mark',

              };

      const sanitized = sanitizeLogData(unicodeBypassData);

      // These Unicode-based keys should now be detected and masked by enhanced security
      Object.keys(unicodeBypassData).forEach(key => {
        const value = sanitized[key];
        expect(value).not.toBe(unicodeBypassData[key]);
        expect(value).toMatch(/(\.\.\.|\[REDACTED\])/);
      });
    });

    it('should PASS: Nested and combined sensitive patterns are now properly detected', () => {
      // Complex nested structures with sensitive data
      const nestedBypassData = {
        // Nested objects with sensitive keys
        config: {
          database: {
            connection_string: 'postgresql://user:password@localhost:5432/db',
            db_credentials: {
              username: 'admin_user',
              pass: 'secret_password_123'
            }
          },
          oauth: {
            providers: {
              google: {
                client_id: 'google_oauth_client_id_123',
                client_secret_key: 'google_oauth_secret_456'
              },
              github: {
                access_token_url: 'https://github.com/login/oauth/access_token',
                token_validation: 'github_validation_secret_789'
              }
            }
          }
        },

        // Arrays containing sensitive data
        api_keys: [
          { name: 'production', key: 'prod_api_key_123' },
          { name: 'staging', api_secret: 'staging_api_secret_456' }
        ],

        // Mixed sensitive and non-sensitive data
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': 'header_api_key_123',
          'Authorization': 'Bearer auth_token_456',
          'X-Auth-Token': 'x_auth_header_token_789'
        }
      };

      const sanitized = sanitizeLogData(nestedBypassData);

      // With enhanced security, sensitive parent keys are now masked entirely
      expect(sanitized.config).toBe('[REDACTED]'); // config is a sensitive key

      // With enhanced security, keys containing sensitive words are masked entirely
      expect(sanitized.api_keys).toBe('[REDACTED]'); // api_keys contains "key" which is sensitive

      // Headers should have sensitive fields masked
      const headers = sanitized.headers as any;
      expect(headers['X-API-Key']).toMatch(/(\.\.\.|\[REDACTED\])/);
      expect(headers['Authorization']).toMatch(/(\.\.\.|\[REDACTED\])/);
      expect(headers['X-Auth-Token']).toMatch(/(\.\.\.|\[REDACTED\])/);
    });

    it('should PASS: Regex pattern detection now handles comprehensive credential formats', () => {
      // Various credential formats that should be detected by regex
      const credentialFormats = {
        // JWT tokens (three parts separated by dots)
        jwt_header: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9',
        jwt_payload: 'eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ',
        jwt_full: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c',

        // API key formats
        vikunja_token: 'tk_1a2b3c4d5e6f7g8h9i0j',
        aws_key: 'AKIAIOSFODNN7EXAMPLE',
        aws_secret: 'wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY',
        github_pat: 'ghp_1234567890abcdef1234567890abcdef12345678',
        slack_token: 'xoxb-FAKE-TOKEN-FOR-TESTING-ONLY',

        // Database connection strings
        mongodb_uri: 'mongodb://username:password@cluster0.mongodb.net:27017/mydb',
        postgresql_uri: 'postgresql://user:secret@localhost:5432/database',
        mysql_uri: 'mysql://admin:password123@db.example.com:3306/app',

        // API endpoints with tokens
        api_with_bearer: 'Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ0ZXN0In0.example',
        basic_auth: 'Basic dXNlcm5hbWU6cGFzc3dvcmQ=', // base64 encoded credentials

        // Certificate and key formats
        private_key_pem: '-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC7VJTUt9Us8cKB',
        certificate: '-----BEGIN CERTIFICATE-----\nMIIDXTCCAkWgAwIBAgIJAKoK8KpJhqCbMA0GCSqGSIb3DQEBBQUAMEUxCzAJBgNV',

        // UUID and session formats
        session_id: '550e8400-e29b-41d4-a716-446655440000',
        request_id: 'req_1234567890abcdef1234567890abcdef',
        trace_id: 'trace_1a2b3c4d5e6f7g8h9i0j',

        // Hash and digest formats
        sha256_hash: 'a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3',
        md5_hash: '5d41402abc4b2a76b9719d911017c592',

        // Base64 encoded data (often contains secrets)
        base64_long: 'VGhpcyBpcyBhIGxvbmcgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRoYXQgY291bGQgY29udGFpbiBzZWNyZXRzIGFuZCBzaG91bGQgYmUgbWFza2VkIGlmIGl0IGxvb2tzIGxpa2UgYSBjcmVkZW50aWFs', // "This is a long base64 encoded string that could contain secrets and should be masked if it looks like a credential"

        // Hex strings (often keys or tokens)
        hex_long: '1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
        hex_medium: '1a2b3c4d5e6f7g8h9i0j'
      };

      const sanitized = sanitizeLogData(credentialFormats);

      // All these credential formats should now be detected and masked by enhanced security
      Object.entries(credentialFormats).forEach(([key, originalValue]) => {
        const sanitizedValue = sanitized[key as keyof typeof sanitized];

        if (typeof originalValue === 'string') {
          // Enhanced security detects more formats
          if (originalValue.length >= 8) { // Reduced threshold for enhanced detection
            expect(sanitizedValue).not.toBe(originalValue);
            expect(sanitizedValue).toMatch(/(\.\.\.|\[REDACTED\])/);
          }
        }
      });
    });

    it('should PASS: Performance-sensitive credential detection works efficiently', () => {
      // Create a large object with many fields to test performance
      const largeObject: Record<string, string> = {};
      const sensitiveFields = [
        'token', 'key', 'secret', 'password', 'auth', 'credential',
        'jwt', 'bearer', 'session', 'access', 'refresh', 'client'
      ];

      // Generate 1000 fields with some sensitive ones mixed in
      for (let i = 0; i < 1000; i++) {
        const fieldPrefix = i % 50 === 0 ? sensitiveFields[i % sensitiveFields.length] : `field_${i}`;
        largeObject[`${fieldPrefix}_${i}`] = `value_${i}_with_sensitive_content_${Math.random().toString(36).substring(2)}`;
      }

      // This should not cause performance issues with enhanced security
      const startTime = performance.now();
      const sanitized = sanitizeLogData(largeObject);
      const endTime = performance.now();

      // Should complete within reasonable time (200ms for enhanced security)
      expect(endTime - startTime).toBeLessThan(200);

      // Sensitive fields should be masked even in large objects
      for (let i = 0; i < 1000; i += 50) {
        const sensitiveField = sensitiveFields[i % sensitiveFields.length];
        const fieldName = `${sensitiveField}_${i}`;

        // Debug which field is failing
        const fieldValue = sanitized[fieldName];
        console.log(`Field: ${fieldName}, value: ${fieldValue}, matches pattern: ${fieldValue && fieldValue.toString().match(/(\.\.\.|\[REDACTED\])/)}`);

        expect(sanitized[fieldName]).toMatch(/(\.\.\.|\[REDACTED\])/);
      }
    });
  });
});